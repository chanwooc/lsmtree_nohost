!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AM_LINK	Makefile	/^AM_LINK= $(AM_V_CCLD)$(CXX) $^ $(EXEC_LDFLAGS) -o $@ $(LDFLAGS) $(COVERAGEFLAGS) $(LIBFTL_LIB)$/;"	m
BOOL	utils.h	54;"	d
BUFFER_READ	LR_inter.h	14;"	d
BUSYPOINT	utils.h	17;"	d
CACHENUM	utils.h	32;"	d
CC	Makefile	/^CC=${HOST}-g++ -D_FILE_OFFSET_BITS=64$/;"	m
CXX	Makefile	/^CXX=${HOST}-g++ -D_FILE_OFFSET_BITS=64$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = $(CFLAGS)$/;"	m
Child	bptree.h	/^typedef union Child{$/;"	u
Child	bptree.h	/^}Child;$/;"	t	typeref:union:Child
DISK_READ	LR_inter.h	15;"	d
ENDMERGE	utils.h	25;"	d
Entry	bptree.h	/^typedef struct Entry{$/;"	s
Entry	bptree.h	/^}Entry;$/;"	t	typeref:struct:Entry
FILTERBIT	utils.h	10;"	d
FILTERFUNC	utils.h	9;"	d
FILTERSIZE	utils.h	8;"	d
GETTEST	utils.h	30;"	d
INPUTSIZE	utils.h	16;"	d
KEYN	utils.h	12;"	d
KEYT	utils.h	7;"	d
LD	Makefile	/^LD=${HOST}-ld$/;"	m
LEVELN	utils.h	15;"	d
LIBFTL_LIB	Makefile	/^LIBFTL_LIB= ..\/..\/..\/bdbm_drv\/frontend\/libmemio\/libmemio.a$/;"	m
LR_COMP_T	LR_inter.h	17;"	d
LR_DDR_T	LR_inter.h	21;"	d
LR_DDW_T	LR_inter.h	22;"	d
LR_DR_T	LR_inter.h	20;"	d
LR_DW_T	LR_inter.h	19;"	d
LR_FLUSH_T	LR_inter.h	18;"	d
LR_READ_T	LR_inter.h	13;"	d
LR_WRITE_T	LR_inter.h	16;"	d
LSM	LR_inter.cpp	/^lsmtree *LSM;$/;"	v
MA	utils.h	46;"	d
MAXC	utils.h	26;"	d
MAXNODE	utils.h	27;"	d
MAX_L	skiplist.h	3;"	d
MC	utils.h	44;"	d
MC	utils.h	51;"	d
ME	utils.h	42;"	d
ME	utils.h	49;"	d
MP	utils.h	43;"	d
MP	utils.h	50;"	d
MR	utils.h	45;"	d
MS	utils.h	41;"	d
MS	utils.h	48;"	d
MT	utils.h	40;"	d
MUL	utils.h	14;"	d
MeasureTime	measure.h	/^typedef struct MeasureTime{$/;"	s
MeasureTime	measure.h	/^}MeasureTime;$/;"	t	typeref:struct:MeasureTime
Node	bptree.h	/^typedef struct Node{$/;"	s
Node	bptree.h	/^}Node;$/;"	t	typeref:struct:Node
OBJECTS	Makefile	/^OBJECTS = server.o command.o queue.o request.o priority_queue.o lsmtree.o bptree.o utils.o measure.o skiplist.o threading.o LR_inter.o$/;"	m
OBJECTS2	Makefile	/^OBJECTS2 = lsmtree.o bptree.o measure.o skiplist.o threading.o LR_inter.o lsm_main.o lsm_cache.o$/;"	m
PAGESIZE	utils.h	13;"	d
READTEST	utils.h	29;"	d
SEQUENCE	utils.h	28;"	d
SKIP_META	utils.h	36;"	d
SNODE_SIZE	utils.h	34;"	d
STARTMERGE	utils.h	24;"	d
THREAD	utils.h	20;"	d
THREADNUM	utils.h	19;"	d
THREADQN	utils.h	18;"	d
__BP__HEADER__	bptree.h	2;"	d
__CACHE_H__	lsm_cache.h	2;"	d
__LR_INTER_H__	LR_inter.h	2;"	d
__LSM_HEADER__	lsmtree.h	2;"	d
__MEASURE_H__	measure.h	2;"	d
__MPMC_BOUNDED_QUEUE_INCLUDED__	lfmpmc.h	31;"	d
__SKIPLIST_HEADER	skiplist.h	2;"	d
__SPSC_BOUNDED_QUEUE_INCLUDED__	lockfreeq.h	35;"	d
__STDC_FORMAT_MACROS	threading.cpp	14;"	d	file:
__THREAD_H__	threading.h	2;"	d
__UTIL_H__	utils.h	2;"	d
_buffer	lfmpmc.h	/^		node_t* const       _buffer;$/;"	m	class:mpmc_bounded_queue_t
_buffer	lockfreeq.h	/^		T* const            _buffer;$/;"	m	class:spsc_bounded_queue_t
_head	lockfreeq.h	/^		std::atomic<size_t> _head;$/;"	m	class:spsc_bounded_queue_t
_head_seq	lfmpmc.h	/^		std::atomic<size_t> _head_seq;$/;"	m	class:mpmc_bounded_queue_t
_mask	lfmpmc.h	/^		const size_t        _mask;$/;"	m	class:mpmc_bounded_queue_t
_mask	lockfreeq.h	/^		const size_t        _mask;$/;"	m	class:spsc_bounded_queue_t
_pad0	lfmpmc.h	/^		cache_line_pad_t    _pad0;$/;"	m	class:mpmc_bounded_queue_t
_pad0	lockfreeq.h	/^		cache_line_pad_t    _pad0;$/;"	m	class:spsc_bounded_queue_t
_pad1	lfmpmc.h	/^		cache_line_pad_t    _pad1;$/;"	m	class:mpmc_bounded_queue_t
_pad1	lockfreeq.h	/^		cache_line_pad_t    _pad1;$/;"	m	class:spsc_bounded_queue_t
_pad2	lfmpmc.h	/^		cache_line_pad_t    _pad2;$/;"	m	class:mpmc_bounded_queue_t
_pad2	lockfreeq.h	/^		cache_line_pad_t    _pad2;$/;"	m	class:spsc_bounded_queue_t
_pad3	lfmpmc.h	/^		cache_line_pad_t    _pad3;$/;"	m	class:mpmc_bounded_queue_t
_size	lfmpmc.h	/^		const size_t        _size;$/;"	m	class:mpmc_bounded_queue_t
_size	lockfreeq.h	/^		const size_t        _size;$/;"	m	class:spsc_bounded_queue_t
_tail	lockfreeq.h	/^		std::atomic<size_t> _tail;$/;"	m	class:spsc_bounded_queue_t
_tail_seq	lfmpmc.h	/^		std::atomic<size_t> _tail_seq;$/;"	m	class:mpmc_bounded_queue_t
activated_check	threading.h	/^	pthread_mutex_t activated_check;$/;"	m	struct:threading
activated_cond	threading.h	/^	pthread_cond_t activated_cond;$/;"	m	struct:threading
activatednum	threading.h	/^	int activatednum;$/;"	m	struct:threadset
adding	measure.h	/^	struct timeval adding;$/;"	m	struct:MeasureTime	typeref:struct:MeasureTime::timeval
aligned_node_t	lfmpmc.h	/^		typedef typename std::aligned_storage<sizeof(node_t), std::alignment_of<node_t>::value>::type aligned_node_t;$/;"	t	class:mpmc_bounded_queue_t
aligned_t	lockfreeq.h	/^		typedef typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type aligned_t;$/;"	t	class:spsc_bounded_queue_t
at	threading.cpp	/^MeasureTime *at;$/;"	v
big_time_check	LR_inter.cpp	/^int big_time_check;$/;"	v
binary_search_node	bptree.c	/^Node* binary_search_node(Node *node, KEYT key){$/;"	f
bool	utils.h	/^typedef enum{false,true} bool;$/;"	t	typeref:enum:__anon3
bp	lsmtree.cpp	/^MeasureTime bp;$/;"	v
buf	lsmtree.cpp	/^MeasureTime buf;$/;"	v
buf	lsmtree.h	/^	buffer buf;$/;"	m	struct:lsmtree
buf_data	threading.h	/^	sktable *buf_data;$/;"	m	struct:threading
buffer	lsmtree.h	/^typedef struct buffer{$/;"	s
buffer	lsmtree.h	/^}buffer;$/;"	t	typeref:struct:buffer
buffer_free	lsmtree.cpp	/^void buffer_free(buffer *buf){$/;"	f
cache	lsm_cache.h	/^}cache;$/;"	t	typeref:struct:__anon1
cache_clear	lsm_cache.c	/^void cache_clear(lsm_cache *input){$/;"	f
cache_hit	threading.h	/^	int cache_hit;$/;"	m	struct:threading
cache_init	lsm_cache.c	/^void cache_init(lsm_cache *input){$/;"	f
cache_input	lsm_cache.c	/^void cache_input(lsm_cache* input,int l,sktable* sk){$/;"	f
cache_level_find	lsm_cache.c	/^keyset* cache_level_find(lsm_cache* input,int l,KEYT k){$/;"	f
cache_line_pad_t	lfmpmc.h	/^		typedef char cache_line_pad_t[64]; \/\/ it's either 32 or 64 so 64 is good enough$/;"	t	class:mpmc_bounded_queue_t
cache_line_pad_t	lockfreeq.h	/^		typedef char cache_line_pad_t[64];$/;"	t	class:spsc_bounded_queue_t
cache_read_lock	lsm_cache.h	/^	pthread_mutex_t cache_read_lock[LEVELN][CACHENUM];$/;"	m	struct:__anon2
cache_write_lock	lsm_cache.h	/^	pthread_mutex_t cache_write_lock[LEVELN][CACHENUM];$/;"	m	struct:__anon2
caches	lsm_cache.h	/^	cache caches[LEVELN][CACHENUM];$/;"	m	struct:__anon2
call	measure.h	/^	int call;$/;"	m	struct:MeasureTime
children	bptree.h	/^	Child children[MAXC+1];$/;"	m	struct:Node
cnnt	lsm_main.c	/^int cnnt=0;$/;"	v
cnt	measure.h	/^	int cnt;$/;"	m	struct:MeasureTime
compaction	lsmtree.cpp	/^bool compaction(lsmtree *LSM,level *src, level *des,Entry *ent,lsmtree_gc_req_t * req){$/;"	f
compt_headers	LR_inter.h	/^	sktable *compt_headers;$/;"	m	struct:lsmtree_gc_req_t
content	lsm_cache.h	/^	sktable *content;$/;"	m	struct:__anon1
count	bptree.h	/^	short count;$/;"	m	struct:Node
counter	threading.h	/^	int counter;$/;"	m	struct:threadset
data	lfmpmc.h	/^			T                     data;$/;"	m	struct:mpmc_bounded_queue_t::node_t
data	lsmtree.h	/^	sktable *data;$/;"	m	struct:buffer
debug_m	threading.h	/^	pthread_mutex_t debug_m;$/;"	m	struct:threadset
depth	bptree.h	/^	int depth;$/;"	m	struct:level
dequeue	lfmpmc.h	/^			dequeue($/;"	f	class:mpmc_bounded_queue_t
dequeue	lockfreeq.h	/^			dequeue($/;"	f	class:spsc_bounded_queue_t
dfd	lsmtree.h	/^	int dfd;$/;"	m	struct:lsmtree
dfd_lock	skiplist.c	/^pthread_mutex_t dfd_lock;$/;"	v
disk	lsmtree.h	/^	level *disk[LEVELN];$/;"	m	struct:buffer
dmaTag	LR_inter.h	/^	int dmaTag;$/;"	m	struct:req_t
dmatag	LR_inter.h	/^	int dmatag;$/;"	m	struct:lsmtree_gc_req_t
dmatag	LR_inter.h	/^	int dmatag;$/;"	m	struct:lsmtree_req_t
dmatag	threading.h	/^	int dmatag;$/;"	m	struct:threading
donothing	measure.c	/^void donothing(MeasureTime *t){$/;"	f
donothing2	measure.c	/^void donothing2(MeasureTime *t,char *a){$/;"	f
dummy	LR_inter.h	/^	char *dummy;$/;"	m	struct:lsmtree_req_t
end	bptree.h	/^	KEYT end;$/;"	m	struct:Entry
end	measure.h	/^	struct timeval start,end;$/;"	m	struct:linktime	typeref:struct:linktime::
end	skiplist.h	/^	KEYT start,end;$/;"	m	struct:skiplist
endR	LR_inter.cpp	/^pthread_mutex_t endR;$/;"	v
end_req	LR_inter.h	/^	int8_t (*end_req)(lsmtree_gc_req_t *);$/;"	m	struct:lsmtree_gc_req_t
end_req	LR_inter.h	/^	int8_t (*end_req)(lsmtree_req_t *);$/;"	m	struct:lsmtree_req_t
end_req	LR_inter.h	/^	int8_t (*end_req)(void*);$/;"	m	struct:req_t
enqueue	lfmpmc.h	/^			enqueue($/;"	f	class:mpmc_bounded_queue_t
enqueue	lockfreeq.h	/^			enqueue($/;"	f	class:spsc_bounded_queue_t
entry	bptree.h	/^	struct Entry *entry;$/;"	m	union:Child	typeref:struct:Child::Entry
errcnt	threading.h	/^	int errcnt;$/;"	m	struct:threadset
false	utils.h	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3
find	lsmtree.cpp	/^MeasureTime find;$/;"	v
flag	LR_inter.h	/^	uint8_t flag;$/;"	m	struct:lsmtree_gc_req_t
flag	LR_inter.h	/^	uint8_t flag;$/;"	m	struct:lsmtree_req_t
free_entry	bptree.c	/^void free_entry(Entry *entry){$/;"	f
gc_cond	threading.h	/^	pthread_cond_t gc_cond;$/;"	m	struct:threadset
gc_full_cond	threading.h	/^	pthread_cond_t gc_full_cond;$/;"	m	struct:threadset
gc_lock	threading.h	/^	pthread_mutex_t gc_lock;$/;"	m	struct:threadset
gc_parent	LR_inter.h	/^	struct lsmtree_gc_req_t *gc_parent;$/;"	m	struct:lsmtree_req_t	typeref:struct:lsmtree_req_t::lsmtree_gc_req_t
gc_q	threading.h	/^	spsc_bounded_queue_t<void *>* gc_q;$/;"	m	struct:threadset
gc_thread	threading.h	/^	threading gc_thread;$/;"	m	struct:threadset
get	lsmtree.cpp	/^int get(lsmtree *LSM,KEYT key,char *ret){\/*$/;"	f
getLevel	skiplist.c	/^static int getLevel(){$/;"	f	file:
gt	threading.cpp	/^MeasureTime gt;$/;"	v
header	measure.h	/^	linktime *header;$/;"	m	struct:MeasureTime
header	skiplist.h	/^	snode *header;$/;"	m	struct:skiplist
header_read	threading.h	/^	int header_read;$/;"	m	struct:threading
id	threading.h	/^	pthread_t id;$/;"	m	struct:threading
init_lsm	lsmtree.cpp	/^lsmtree* init_lsm(lsmtree *res){$/;"	f
is_compt_needed	lsmtree.cpp	/^bool is_compt_needed(lsmtree *input, KEYT level){$/;"	f
is_flush_needed	lsmtree.cpp	/^bool is_flush_needed(lsmtree *input){$/;"	f
isactivated	threading.h	/^	bool isactivated;$/;"	m	struct:threading
isempty	lfmpmc.h	/^			isempty()$/;"	f	class:mpmc_bounded_queue_t
isempty	lockfreeq.h	/^		bool isempty(){$/;"	f	class:spsc_bounded_queue_t
isgc	LR_inter.h	/^	bool isgc;$/;"	m	struct:lsmtree_gc_req_t
isgc	LR_inter.h	/^	bool isgc;$/;"	m	struct:lsmtree_req_t
key	LR_inter.h	/^	uint64_t key;$/;"	m	struct:req_t
key	bptree.h	/^	KEYT key;$/;"	m	struct:Entry
key	skiplist.h	/^	KEYT key;$/;"	m	struct:keyset
key	skiplist.h	/^	KEYT key;$/;"	m	struct:snode
keys	LR_inter.h	/^ 	keyset *keys;$/;"	m	struct:lsmtree_gc_req_t
keys	LR_inter.h	/^ 	keyset *keys;$/;"	m	struct:lsmtree_req_t
keys	lsm_main.c	/^KEYT *keys;$/;"	v
keyset	LR_inter.h	/^typedef struct keyset keyset;$/;"	t	typeref:struct:keyset
keyset	skiplist.h	/^typedef struct keyset{$/;"	s
keyset	skiplist.h	/^}keyset;$/;"	t	typeref:struct:keyset
last	lsmtree.cpp	/^MeasureTime last;$/;"	v
lastB	lsmtree.h	/^	skiplist *lastB;$/;"	m	struct:buffer
leaf	bptree.h	/^	bool leaf;$/;"	m	struct:Node
lev_addr	lsmtree.h	/^	int lev_addr[LEVELN];$/;"	m	struct:table
level	bptree.h	/^typedef struct level{$/;"	s
level	bptree.h	/^}level;$/;"	t	typeref:struct:level
level	skiplist.h	/^	int level;$/;"	m	struct:snode
level	skiplist.h	/^	uint8_t level;$/;"	m	struct:skiplist
level	threading.h	/^	int level;$/;"	m	struct:threading
level_delete	bptree.c	/^Node * level_delete(level *lev, KEYT key){$/;"	f
level_delete_restructuring	bptree.c	/^Node *level_delete_restructuring(level *lev, Node *target){$/;"	f
level_directory_insert	bptree.c	/^Node *level_directory_insert(level *lev,Node *target, KEYT sep, Node *prev, Node *next){$/;"	f
level_entry_copy	bptree.c	/^Entry *level_entry_copy(Entry *input){$/;"	f
level_find	bptree.c	/^Entry *level_find(level *lev, KEYT key){$/;"	f
level_find_leafnode	bptree.c	/^Node *level_find_leafnode(level *lev, KEYT key){$/;"	f
level_free	bptree.c	/^void level_free(level *lev){$/;"	f
level_getFirst	bptree.c	/^Entry *level_getFirst(level *lev){$/;"	f
level_get_victim	bptree.c	/^Entry *level_get_victim(level *lev){$/;"	f
level_init	bptree.c	/^level *level_init(level* input, int size){$/;"	f
level_insert	bptree.c	/^Node *level_insert(level* lev, Entry *entry){$/;"	f
level_range_find	bptree.c	/^Entry **level_range_find(level *lev, KEYT start, KEYT end){$/;"	f
linktime	measure.h	/^typedef struct linktime{$/;"	s
linktime	measure.h	/^}linktime;$/;"	t	typeref:struct:linktime
list	skiplist.h	/^	struct snode **list;$/;"	m	struct:snode	typeref:struct:snode::snode
lr_end_req	LR_inter.cpp	/^int8_t lr_end_req(lsmtree_req_t *r){$/;"	f
lr_gc_end_req	LR_inter.cpp	/^int8_t lr_gc_end_req(lsmtree_gc_req_t *r){$/;"	f
lr_gc_make_req	LR_inter.cpp	/^int8_t lr_gc_make_req(int8_t t_num){$/;"	f
lr_gc_req_wait	LR_inter.cpp	/^int8_t lr_gc_req_wait(lsmtree_gc_req_t *input){$/;"	f
lr_inter_free	LR_inter.cpp	/^int8_t lr_inter_free(){$/;"	f
lr_inter_init	LR_inter.cpp	/^int8_t lr_inter_init(){$/;"	f
lr_is_gc_needed	LR_inter.cpp	/^int8_t lr_is_gc_needed(){$/;"	f
lr_make_req	LR_inter.cpp	/^int8_t lr_make_req(req_t *r){$/;"	f
lr_req_wait	LR_inter.cpp	/^int8_t lr_req_wait(lsmtree_req_t *input){$/;"	f
lsm_cache	lsm_cache.h	/^}lsm_cache;$/;"	t	typeref:struct:__anon2
lsm_clear	lsmtree.cpp	/^void lsm_clear(lsmtree *input){$/;"	f
lsm_free	lsmtree.cpp	/^void lsm_free(lsmtree *input){$/;"	f
lsm_reset	lsmtree.cpp	/^lsmtree* lsm_reset(lsmtree* input){$/;"	f
lsmtree	lsmtree.h	/^typedef struct lsmtree{$/;"	s
lsmtree	lsmtree.h	/^}lsmtree;$/;"	t	typeref:struct:lsmtree
lsmtree_gc_req_t	LR_inter.h	/^typedef struct lsmtree_gc_req_t{$/;"	s
lsmtree_gc_req_t	LR_inter.h	/^}lsmtree_gc_req_t;$/;"	t	typeref:struct:lsmtree_gc_req_t
lsmtree_gc_req_t	skiplist.h	/^typedef struct lsmtree_gc_req_t lsmtree_gc_req_t;$/;"	t	typeref:struct:lsmtree_gc_req_t
lsmtree_req_t	LR_inter.h	/^typedef struct lsmtree_req_t{$/;"	s
lsmtree_req_t	LR_inter.h	/^}lsmtree_req_t;$/;"	t	typeref:struct:lsmtree_req_t
lsmtree_req_t	skiplist.h	/^typedef struct lsmtree_req_t lsmtree_req_t;$/;"	t	typeref:struct:lsmtree_req_t
m_size	bptree.h	/^	int m_size;$/;"	m	struct:level
main	bptree.c	/^int main(){$/;"	f
main	lsm_main.c	/^int main(){$/;"	f
main	measure.c	/^int main(){$/;"	f
main	skiplist.c	/^int main(){$/;"	f
make_cnt	LR_inter.cpp	/^int make_cnt=1;$/;"	v
make_entry	bptree.c	/^Entry *make_entry(KEYT key,KEYT end,KEYT pbn1){$/;"	f
mas	LR_inter.cpp	/^MeasureTime mas;$/;"	v
mas2	LR_inter.cpp	/^MeasureTime mas2;$/;"	v
master	threading.h	/^	threadset *master;$/;"	m	struct:threading
max_act	threading.h	/^	int max_act;$/;"	m	struct:threadset
max_time	LR_inter.cpp	/^struct timeval max_time;$/;"	v	typeref:struct:timeval
measure_adding	measure.c	/^void measure_adding(MeasureTime *m){$/;"	f
measure_end	measure.c	/^void measure_end(MeasureTime *m,char *format){$/;"	f
measure_end	measure.c	/^void measure_end(MeasureTime *m,std::string input ){$/;"	f
measure_init	measure.c	/^void measure_init(MeasureTime *m){$/;"	f
measure_pop	measure.c	/^void measure_pop(MeasureTime *m){$/;"	f
measure_res	measure.c	/^struct timeval measure_res(MeasureTime *m){$/;"	f
measure_stamp	measure.c	/^void measure_stamp(MeasureTime *m){$/;"	f
measure_start	measure.c	/^void measure_start(MeasureTime *m){$/;"	f
mem	lsmtree.cpp	/^MeasureTime mem;$/;"	v
mem_lock	lsmtree.cpp	/^pthread_mutex_t mem_lock;$/;"	v
memtree	lsmtree.h	/^	skiplist *memtree;$/;"	m	struct:lsmtree
merge	lsmtree.cpp	/^bool merge(lsmtree *LSM,KEYT target,skiplist *list){\/*$/;"	f
meta	LR_inter.h	/^	spsc_bounded_queue_t <void *>meta;$/;"	m	struct:lsmtree_gc_req_t
meta	LR_inter.h	/^	spsc_bounded_queue_t<void *>* meta;$/;"	m	struct:lsmtree_req_t
meta	skiplist.h	/^	keyset meta[KEYN];$/;"	m	struct:sktable
meta_lock	LR_inter.h	/^	pthread_mutex_t meta_lock;$/;"	m	struct:lsmtree_gc_req_t
meta_lock	LR_inter.h	/^	pthread_mutex_t meta_lock;$/;"	m	struct:lsmtree_req_t
meta_read_data	lsmtree.cpp	/^int meta_read_data;$/;"	v
mio	lsmtree.cpp	/^memio_t* mio;$/;"	v
mpmc_bounded_queue_t	lfmpmc.h	/^		mpmc_bounded_queue_t($/;"	f	class:mpmc_bounded_queue_t
mpmc_bounded_queue_t	lfmpmc.h	/^		mpmc_bounded_queue_t(const mpmc_bounded_queue_t&) {}$/;"	f	class:mpmc_bounded_queue_t
mpmc_bounded_queue_t	lfmpmc.h	/^class mpmc_bounded_queue_t$/;"	c
mt	LR_inter.cpp	/^MeasureTime mt;$/;"	v
mt	LR_inter.h	/^	MeasureTime mt;$/;"	m	struct:lsmtree_gc_req_t
mt	LR_inter.h	/^	MeasureTime mt;$/;"	m	struct:lsmtree_req_t
mycache	threading.h	/^	lsm_cache mycache;$/;"	m	struct:threadset
mylist	skiplist.h	/^	skiplist *mylist;$/;"	m	struct:skIterator
next	measure.h	/^	struct linktime * next;$/;"	m	struct:linktime	typeref:struct:linktime::linktime
node	bptree.h	/^	struct Node *node;$/;"	m	union:Child	typeref:struct:Child::Node
node_init	bptree.c	/^Node *node_init(Node *node){$/;"	f
node_t	lfmpmc.h	/^		struct node_t$/;"	s	class:mpmc_bounded_queue_t
now	skiplist.h	/^	snode *now;$/;"	m	struct:skIterator
now_number	LR_inter.h	/^	uint64_t now_number;$/;"	m	struct:lsmtree_gc_req_t
now_number	LR_inter.h	/^	uint64_t now_number;$/;"	m	struct:lsmtree_req_t
number	bptree.h	/^	int number;$/;"	m	struct:level
number	threading.h	/^	int number;$/;"	m	struct:threading
operator =	lfmpmc.h	/^		void operator=(const mpmc_bounded_queue_t&) {}$/;"	f	class:mpmc_bounded_queue_t
operator =	lockfreeq.h	/^		void operator=(const spsc_bounded_queue_t&) {}$/;"	f	class:spsc_bounded_queue_t
params	LR_inter.h	/^	void *params[4];$/;"	m	struct:lsmtree_gc_req_t
params	LR_inter.h	/^	void *params[4];$/;"	m	struct:lsmtree_req_t
parent	LR_inter.h	/^	struct lsmtree_gc_req_t *parent;$/;"	m	struct:lsmtree_gc_req_t	typeref:struct:lsmtree_gc_req_t::lsmtree_gc_req_t
parent	LR_inter.h	/^	struct lsmtree_req_t *parent;$/;"	m	struct:lsmtree_req_t	typeref:struct:lsmtree_req_t::lsmtree_req_t
parent	bptree.h	/^	struct Node *parent;$/;"	m	struct:Entry	typeref:struct:Entry::Node
parent	bptree.h	/^	struct Node *parent;$/;"	m	struct:Node	typeref:struct:Node::Node
pbn	bptree.h	/^	KEYT pbn;$/;"	m	struct:Entry
pl	LR_inter.cpp	/^pthread_mutex_t pl;$/;"	v
ppa	skiplist.c	/^KEYT ppa=0;$/;"	v
ppa	skiplist.h	/^	KEYT ppa;$/;"	m	struct:keyset
ppa	skiplist.h	/^	KEYT ppa;$/;"	m	struct:snode
print_lock	LR_inter.cpp	/^pthread_mutex_t print_lock;$/;"	v
processor	LR_inter.cpp	/^threadset processor;$/;"	v
put	lsmtree.cpp	/^bool put(lsmtree *LSM,KEYT key, char *value,lsmtree_req_t *req){$/;"	f
read_cnt	lsm_cache.h	/^	int read_cnt[LEVELN][CACHENUM];$/;"	m	struct:__anon2
read_cond	threading.cpp	/^pthread_cond_t read_cond;$/;"	v
read_lock	threading.cpp	/^pthread_mutex_t read_lock;$/;"	v
read_q	threading.h	/^	mpmc_bounded_queue_t<void *> *read_q;$/;"	m	struct:threadset
req	LR_inter.h	/^	req_t *req;$/;"	m	struct:lsmtree_req_t
req	LR_inter.h	/^	req_t *req;\/\/always NULL$/;"	m	struct:lsmtree_gc_req_t
req	skiplist.h	/^	struct lsmtree_req_t *req;$/;"	m	struct:snode	typeref:struct:snode::lsmtree_req_t
req_lock	threading.h	/^	pthread_mutex_t req_lock;$/;"	m	struct:threadset
req_q	threading.h	/^	spsc_bounded_queue_t<void *>* req_q;$/;"	m	struct:threadset
req_t	LR_inter.h	/^	typedef struct req_t req_t;$/;"	t	typeref:struct:req_t
req_t	LR_inter.h	/^typedef struct req_t{$/;"	s
req_t	LR_inter.h	/^}req_t;$/;"	t	typeref:struct:req_t
res	LR_inter.h	/^	sktable *res;$/;"	m	struct:lsmtree_gc_req_t
res	LR_inter.h	/^	sktable *res;$/;"	m	struct:lsmtree_req_t
root	bptree.h	/^	Node *root;$/;"	m	struct:level
rt	threading.cpp	/^MeasureTime rt;$/;"	v
separator	bptree.h	/^	KEYT separator[MAXC];$/;"	m	struct:Node
seq	lfmpmc.h	/^			std::atomic<size_t>   seq;$/;"	m	struct:mpmc_bounded_queue_t::node_t
seq_number	LR_inter.h	/^	uint64_t seq_number;$/;"	m	struct:lsmtree_gc_req_t
seq_number	LR_inter.h	/^	uint64_t seq_number;$/;"	m	struct:lsmtree_req_t
seq_number	skiplist.c	/^int seq_number=0;$/;"	v
size	bptree.h	/^	int size;$/;"	m	struct:level
size	skiplist.h	/^	uint64_t size;$/;"	m	struct:skiplist
skIterator	skiplist.h	/^typedef struct skIterator{$/;"	s
skIterator	skiplist.h	/^} skIterator;$/;"	t	typeref:struct:skIterator
sk_now_number	threading.h	/^	int sk_now_number;$/;"	m	struct:threadset
sk_target_number	threading.h	/^	int sk_target_number;$/;"	m	struct:threadset
skip_data	LR_inter.h	/^	skiplist * skip_data;$/;"	m	struct:lsmtree_gc_req_t
skiplist	LR_inter.h	/^typedef struct skiplist skiplist;$/;"	t	typeref:struct:skiplist
skiplist	skiplist.h	/^typedef struct skiplist{$/;"	s
skiplist	skiplist.h	/^}skiplist;$/;"	t	typeref:struct:skiplist
skiplist_cut	skiplist.c	/^skiplist *skiplist_cut(skiplist *list,KEYT num){$/;"	f
skiplist_data_read	skiplist.c	/^sktable* skiplist_data_read(sktable *list, KEYT pbn, int fd){\/*$/;"	f
skiplist_data_write	skiplist.c	/^KEYT skiplist_data_write(skiplist *data,int fd,lsmtree_gc_req_t * req){$/;"	f
skiplist_dump	skiplist.c	/^void skiplist_dump(skiplist *list){$/;"	f
skiplist_ex_value_free	skiplist.c	/^void skiplist_ex_value_free(skiplist *list){$/;"	f
skiplist_find	skiplist.c	/^snode *skiplist_find(skiplist *list, KEYT key){$/;"	f
skiplist_find_level	skiplist.c	/^static snode * skiplist_find_level(KEYT key, int level, skiplist *list){$/;"	f	file:
skiplist_free	skiplist.c	/^void skiplist_free(skiplist *list){$/;"	f
skiplist_init	skiplist.c	/^skiplist *skiplist_init(skiplist *point){$/;"	f
skiplist_insert	skiplist.c	/^snode *skiplist_insert(skiplist *list,KEYT key, char *value, lsmtree_req_t* req,bool flag){$/;"	f
skiplist_keyset_find	skiplist.c	/^keyset *skiplist_keyset_find(sktable *t, KEYT key){$/;"	f
skiplist_keyset_read	skiplist.c	/^bool skiplist_keyset_read(keyset* k,char *res,int fd,lsmtree_req_t *req){$/;"	f
skiplist_meta_free	skiplist.c	/^void skiplist_meta_free(skiplist *list){$/;"	f
skiplist_meta_read_c	skiplist.c	/^sktable *skiplist_meta_read_c(KEYT pbn, int fd,int seq,lsmtree_gc_req_t *req){$/;"	f
skiplist_meta_read_n	skiplist.c	/^sktable *skiplist_meta_read_n(KEYT pbn, int fd,int seq,lsmtree_req_t *req){$/;"	f
skiplist_meta_write	skiplist.c	/^KEYT skiplist_meta_write(skiplist *data,int fd, lsmtree_gc_req_t *req){$/;"	f
skiplist_pop	skiplist.c	/^snode *skiplist_pop(skiplist *list){$/;"	f
skiplist_read	skiplist.c	/^sktable *skiplist_read(KEYT pbn, int hfd, int dfd){$/;"	f
skiplist_sktable_free	skiplist.c	/^void skiplist_sktable_free(sktable *f){$/;"	f
skiplist_write	skiplist.c	/^KEYT skiplist_write(skiplist *data, lsmtree_gc_req_t * req,int hfd,int dfd){$/;"	f
sktable	LR_inter.h	/^typedef struct sktable sktable;$/;"	t	typeref:struct:sktable
sktable	skiplist.h	/^typedef struct sktable{$/;"	s
sktable	skiplist.h	/^}sktable;$/;"	t	typeref:struct:sktable
snode	skiplist.h	/^typedef struct snode{$/;"	s
snode	skiplist.h	/^}snode;$/;"	t	typeref:struct:snode
snode_init	skiplist.c	/^snode *snode_init(snode *node){$/;"	f
spsc_bounded_queue_t	lockfreeq.h	/^		spsc_bounded_queue_t($/;"	f	class:spsc_bounded_queue_t
spsc_bounded_queue_t	lockfreeq.h	/^		spsc_bounded_queue_t(const spsc_bounded_queue_t&) {}$/;"	f	class:spsc_bounded_queue_t
spsc_bounded_queue_t	lockfreeq.h	/^class spsc_bounded_queue_t$/;"	c
sst_lock	lsmtree.cpp	/^pthread_mutex_t sst_lock;$/;"	v
sstable	lsmtree.h	/^	skiplist *sstable;$/;"	m	struct:lsmtree
start	measure.h	/^	struct timeval start,end;$/;"	m	struct:linktime	typeref:struct:linktime::timeval
start	skiplist.h	/^	KEYT start,end;$/;"	m	struct:skiplist
table	lsmtree.h	/^typedef struct table{$/;"	s
table	lsmtree.h	/^}table;$/;"	t	typeref:struct:table
target_number	LR_inter.h	/^	uint64_t target_number;$/;"	m	struct:lsmtree_gc_req_t
target_number	LR_inter.h	/^	uint64_t target_number;$/;"	m	struct:lsmtree_req_t
terminate	threading.h	/^	pthread_mutex_t terminate;$/;"	m	struct:threading
terminateflag	threading.h	/^	bool terminateflag;$/;"	m	struct:threading
th_cnt_lock	threading.h	/^	pthread_mutex_t th_cnt_lock;$/;"	m	struct:threadset
thread_disk_get	lsmtree.cpp	/^int thread_disk_get(lsmtree *LSM, KEYT key, lsmtree_req_t *req, int level){$/;"	f
thread_gc_main	threading.cpp	/^void* thread_gc_main(void *input){$/;"	f
thread_get	lsmtree.cpp	/^int thread_get(lsmtree *LSM, KEYT key, threading *input, char *ret,lsmtree_req_t* req){$/;"	f
thread_main	threading.cpp	/^void* thread_main(void *input){$/;"	f
threading	lsmtree.h	/^typedef struct threading threading;$/;"	t	typeref:struct:threading
threading	threading.h	/^typedef struct threading{$/;"	s
threading	threading.h	/^}threading;$/;"	t	typeref:struct:threading
threading_clear	threading.cpp	/^void threading_clear(threading *input){$/;"	f
threading_init	threading.cpp	/^void threading_init(threading *input){$/;"	f
threads	threading.h	/^	threading threads[THREADNUM];$/;"	m	struct:threadset
threadset	threading.h	/^typedef struct threadset threadset;$/;"	t	typeref:struct:threadset
threadset	threading.h	/^typedef struct threadset{$/;"	s
threadset	threading.h	/^}threadset;$/;"	t	typeref:struct:threadset
threadset_assign	threading.cpp	/^void threadset_assign(threadset* input, lsmtree_req_t *req){$/;"	f
threadset_clear	threading.cpp	/^void threadset_clear(threadset *input){$/;"	f
threadset_debug_print	threading.cpp	/^void threadset_debug_print(threadset *input){$/;"	f
threadset_end	threading.cpp	/^void threadset_end(threadset *input){$/;"	f
threadset_gc_assign	threading.cpp	/^void threadset_gc_assign(threadset* input ,lsmtree_gc_req_t *req){$/;"	f
threadset_gc_wait	threading.cpp	/^void threadset_gc_wait(threadset *input){$/;"	f
threadset_init	threading.cpp	/^void threadset_init(threadset* input){$/;"	f
threadset_read_assign	threading.cpp	/^void threadset_read_assign(threadset* input, lsmtree_req_t *req){$/;"	f
threadset_read_wait	threading.cpp	/^void threadset_read_wait(threadset *input){$/;"	f
threadset_request_wait	threading.cpp	/^void threadset_request_wait(threadset *input){$/;"	f
threadset_start	threading.cpp	/^void threadset_start(threadset* input){$/;"	f
tlb	lsmtree.h	/^	table tlb;$/;"	m	struct:lsmtree
true	utils.h	/^typedef enum{false,true} bool;$/;"	e	enum:__anon3
type	LR_inter.h	/^	uint8_t type;$/;"	m	struct:lsmtree_gc_req_t
type	LR_inter.h	/^	uint8_t type;$/;"	m	struct:lsmtree_req_t
type	LR_inter.h	/^	uint8_t type;$/;"	m	struct:req_t
value	LR_inter.h	/^	char *value;$/;"	m	struct:req_t
value	skiplist.h	/^	char *value;$/;"	m	struct:sktable
value	skiplist.h	/^	char *value;$/;"	m	struct:snode
version	bptree.h	/^	KEYT version;$/;"	m	struct:Entry
version	bptree.h	/^	KEYT version;$/;"	m	struct:level
victim	lsm_cache.h	/^	int victim[LEVELN];$/;"	m	struct:__anon2
waiting	threading.h	/^	MeasureTime waiting;$/;"	m	struct:threading
write_data	lsmtree.cpp	/^KEYT write_data(lsmtree *LSM,skiplist *input,lsmtree_gc_req_t *req){$/;"	f
write_flag	threading.h	/^	bool write_flag;$/;"	m	struct:threadset
write_meta_only	lsmtree.cpp	/^int write_meta_only(lsmtree *LSM, skiplist *data,lsmtree_gc_req_t * input){$/;"	f
wt	threading.cpp	/^MeasureTime *wt;$/;"	v
~mpmc_bounded_queue_t	lfmpmc.h	/^		~mpmc_bounded_queue_t()$/;"	f	class:mpmc_bounded_queue_t
~spsc_bounded_queue_t	lockfreeq.h	/^		~spsc_bounded_queue_t()$/;"	f	class:spsc_bounded_queue_t
