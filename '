#include"run_array.h"
#include<string.h>
#include<stdio.h>
#include<stdlib.h>
Node *ns_run(level*input ,int n){
	return (Node*)&input->body[input->r_size*n];
}
Entry *ns_entry(Node *input, int n){
	return (Entry*)&input->body[input->e_size*n];
}

Entry *level_entcpy(Entry *src, char *des){
	memcpy(des,src,sizeof(Entry));
#ifdef BLOOM
	#ifdef MONKEY

	#else

	#endif
#endif
	return (Entry*)des;
}

level *level_init(level *input,int entry_p_run){
#ifdef Tiering
	input->r_num=MUL;
#else
	input->r_num=1;
#endif
	int run_body_size=sizeof(Entry)*entry_p_run;
	int run_size=sizeof(Node)-sizeof(char*)+run_body_size;
	int level_body_size=run_size*input->r_num;

	input->body=(char*)malloc(level_body_size);
	input->r_size=run_size;
	input->m_num=input->r_num*entry_p_run;
	input->n_num=0;

	for(int i=0; i<input->r_num; i++){
		Node *temp_run=ns_run(input,i);
		temp_run->n_num=0;
		temp_run->m_num=entry_p_run;
		temp_run->e_size=sizeof(Entry);
	}
	
	input->r_n_num=1;
	return input;
}
Entry *level_find(level *input,KEYT key){
	for(int i=0; i<input->r_num; i++){
		Node *run=ns_run(input,i);
#ifdef BLOOM
		//check bloomfilter
#endif
		if(run->n_num==0) break;
		int start=0;
		int end=run->n_num;
		int mid;
		while(1){
			mid=(start+end)/2;
			Entry *mid_e=ns_entry(run,mid);
			if(mid_e->key<= key && mid_e->end>=key)
				return mid_e;
			if(mid_e->key>key){
				end=mid-1;
			}
			else if(mid_e->end<key){
				start=mid+1;
			}
			if(start>end)
				break;
		}
	}
	return NULL;
}
Node *level_insert(level *input,Entry *entry){//always sequential
	if(input->n_num==input->m_num) return NULL;
	int r=input->n_num/input->r_num;
	if(input->r_n_num==r)
		input->r_n_num++;
	Node *temp_run=ns_run(input,r);//active run
	int o=temp_run->n_num;
	Entry *temp_entry=ns_run(temp_run,o);
	level_entcpy(entry,(char*)temp_entry);
	temp_run->n_num++;
	input->n_num++;
}
Entry *level_get_next(Iter * input){
	if(!input->flag) return NULL;
	if(input->now->n_num==0) return NULL;
	Entry *res=ns_entry(input->now,input->idx++);
	if(input->idx==input->now->n_num){
		if(input->lev->r_n_num == input->r_idx){
			input->flag=false;
		}
		else{
			input->r_idx++;
			input->now=ns_node(input->lev,r_idx);
			input->idx=0;
		}
	}
	return res;
}
Iter *level_get_Iter(level *input){
	Iter *res=(Iter*)malloc(sizeof(Iter));
	res->now=ns_node(input,0);
	res->idx=0;
	res->r_idx=0;
	res->lev=input;
	res->flag=true;
	return res;
}
void level_print(level *input){
	for(int i=0; i<input->r_num; i++){
		Node* temp_run=ns_node(input,i);
		for(int j=0; j<temp_run->n_num; i++){
			Entry *temp_ent=ns_entry(temp_run,j);
			printf("Key: %d, End: %d, Pbn: %d\n",temp_ent->key,temp_ent->end,tmep_ent->pbn);
		}
	}
}
void level_free(levle *input){
	free(input->body);	
	free(input);
}
#ifdef BLOOM
Entry *level_make_entry(KEYT key,KEYT end,KEYT pbn,BF* filter){
	Entry *ent=(Entry *)maloc(sizeof(Entry));
	ent->key=key;
	ent->end=end;
	ent->pbn=pbn;
	memset(ent->bitset,0,sizeof(bitset));
	ent->filter=filter;
	return ent;
}
#else
Entry *level_make_entry(KEYT key,KEYT end,KEYT pbn){
	Entry *ent=(Entry *)maloc(sizeof(Entry));
	ent->key=key;
	ent->end=end;
	ent->pbn=pbn;
	memset(ent->bitset,0,sizeof(bitset));
	return ent;
}
#endif

int main(){
	level *temp_lev=(level*)malloc(sizeof(level));
	level_init(temp_lev,24);
	for(int i=0; i<24; i++){
		Entry *temp=level_make_entry(i,i,i);
		level_insert(temp_lev,temp);
		free(temp);
	}
	level_print(temp_lev);
	level_free(temp_lev);
}
