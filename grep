bptree.cpp:Node *level_delete_restructuring(level *lev, Node *target){
bptree.cpp:Node * level_delete(level *lev, KEYT key){
bptree.cpp:		return level_delete_restructuring(lev,temp->parent);
bptree.cpp:	while(level_delete(lev,0)!=NULL){
bptree.cpp:		level_delete(lev,key);
bptree.cpp:		level_delete(lev,temp->key);
bptree.h:Node *level_delete(level*,KEYT);
delete_set.cpp:#include"delete_set.h"
delete_set.cpp:delete_set *data_segment;
delete_set.cpp:delete_set *header_segment;
delete_set.cpp:lsmtree_req_t * delete_make_req(bool iswrite){
delete_set.cpp:void delete_init(){//for test
delete_set.cpp:	data_segment=(delete_set*)malloc(sizeof(delete_set));
delete_set.cpp:	header_segment=(delete_set *)malloc(sizeof(delete_set));
delete_set.cpp:void delete_ppa(delete_set *set,KEYT input){
delete_set.cpp:int delete_get_victim(delete_set *set){
delete_set.cpp:int delete_trim_process_header(delete_set *set){
delete_set.cpp:	int block_num=delete_get_victim(set); //segment's order
delete_set.cpp:				lsmtree_req_t *req=delete_make_req(0);
delete_set.cpp:				req=delete_make_req(1);
delete_set.cpp:				delete_ppa(set,temp_pba);
delete_set.cpp:int delete_trim_process_data(delete_set *set){
delete_set.cpp:	int block_num=delete_get_victim(set);
delete_set.cpp:				lsmtree_req_t *req=delete_make_req(0);
delete_set.cpp:						req=delete_make_req(0);
delete_set.cpp:								req=delete_make_req(1);
delete_set.cpp:								delete_ppa(header_segment,temp_pba);
delete_set.cpp:				req=delete_make_req(1);
delete_set.h:void delete_init();//for oob
delete_set.h:void delete_ppa(delete_set *set,KEYT ppa);
delete_set.h:int delete_trim_process_header(delete_set *);
delete_set.h:int delete_trim_process_data(delete_set *);
delete_set.h:void delete_free(delete_set *);
delete_set.h:void delete_dirty_set(delete_set *,KEYT ppa);
delete_set.h:int delete_get_victim(delete_set *);
lfmpmc.h:			delete[] _buffer;
Binary file LIBLSM matches
Binary file liblsm.a matches
Binary file libmemio.a matches
lockfreeq.h:			delete[] _buffer;
LR_inter.cpp:#include"delete_set.h"
LR_inter.cpp:	delete_init();
LR_inter.cpp://			delete r->meta;
lsm_main.cpp:#include"delete_set.h"
lsm_main.cpp:extern delete_set *header_segment;
lsm_main.cpp:extern delete_set *data_segment;
lsm_main.cpp:	printf("delete end!!\n");
lsm_main.cpp:	while(delete_trim_process_header(header_segment)){
lsm_main.cpp:		printf("deleted!\n");
lsmtree.cpp:#include"delete_set.h"
lsmtree.cpp:extern delete_set *header_segment;
lsmtree.cpp:extern delete_set *data_segment;
lsmtree.cpp:			printf("[%u]deleted\n",temp_key->key);
lsmtree.cpp:				printf("[%u]deleted\n",temp_key->key);
lsmtree.cpp:							printf("[%u]deleted\n",temp_key->key);
lsmtree.cpp:			printf("[%u]deleted\n",res->key);
lsmtree.cpp:			printf("[%u]deleted\n",res->key);
lsmtree.cpp:				printf("[%u]deleted\n",temp_key->key);
lsmtree.cpp:							printf("[%u]deleted\n",temp_key->key);
lsmtree.cpp:	KEYT *delete_sets=NULL;
lsmtree.cpp:	KEYT *delete_pbas=NULL;
lsmtree.cpp:	uint8_t **delete_bitset=NULL;
lsmtree.cpp:	int deleteIdx=0;
lsmtree.cpp:		delete_sets=(KEYT*)malloc(sizeof(KEYT)*(des->m_size));
lsmtree.cpp:		delete_bitset=(uint8_t **)malloc(sizeof(uint8_t*)*(allnumber));
lsmtree.cpp:		delete_pbas=(KEYT*)malloc(sizeof(KEYT)*(allnumber));
lsmtree.cpp:			delete_pbas[counter]=temp_e->pbn;
lsmtree.cpp:			delete_bitset[counter]=temp_e->bitset;
lsmtree.cpp:			delete_sets[deleteIdx++]=temp_e->key;
lsmtree.cpp:				delete_pbas[counter]=iter_temp->pbn;
lsmtree.cpp:				delete_bitset[counter]=iter_temp->bitset;
lsmtree.cpp:	//			delete_ppa(header_segment,iter_temp->pbn);
lsmtree.cpp:			uint8_t *temp_bit=delete_bitset[i];
lsmtree.cpp:			delete_ppa(header_segment,delete_pbas[i]);
lsmtree.cpp:		for(int i=0; i<deleteIdx; i++){
lsmtree.cpp:			level_delete(des,delete_sets[i]);
lsmtree.cpp:	if(delete_sets!=NULL){
lsmtree.cpp:		free(delete_sets);
lsmtree.cpp:	if(delete_pbas!=NULL){
lsmtree.cpp:		free(delete_pbas);
lsmtree.cpp:	if(delete_bitset!=NULL){
lsmtree.cpp:		free(delete_bitset);
Makefile:	delete_set.cpp\
ppa.cpp:#include"delete_set.h"
ppa.cpp:			printf("delete data call!!!!\n");
ppa.cpp:			delete_trim_process_data(input);
ppa.cpp:			printf("delete header call!!!!\n");
ppa.cpp:			delete_trim_process_header(input);
ppa.h:typedef segment delete_set;
skiplist.cpp:#include"delete_set.h"
skiplist.cpp:extern delete_set *header_segment;
skiplist.cpp:extern delete_set *data_segment;
skiplist.cpp:int skiplist_delete(skiplist* list, KEYT key){
skiplist.cpp:		if(x->vflag && !flag){ //delete
skiplist.cpp:			delete_ppa(data_segment,x->ppa);
skiplist.cpp:		else{ //update || write after delete
skiplist.cpp:					delete_ppa(data_segment,x->ppa);
skiplist.cpp:		delete_ppa(data_segment,sk->meta[i].ppa);
tags:FLAGGET	delete_set.h	/^inline bool FLAGGET(uint64_t &des){$/;"	f
tags:FLAGSET	delete_set.h	/^inline uint64_t FLAGSET(uint64_t &des, bool flag){$/;"	f
tags:KEYGET	delete_set.h	/^inline KEYT KEYGET(uint64_t des){$/;"	f
tags:KEYSET	delete_set.h	/^inline uint64_t KEYSET(uint64_t &des,uint32_t src){$/;"	f
tags:LEVELGET	delete_set.h	/^inline uint8_t LEVELGET(uint64_t des){\/\/for header$/;"	f
tags:__DELETE_H__	delete_set.h	2;"	d
tags:data_segment	delete_set.cpp	/^delete_set *data_segment;$/;"	v
tags:delete_get_victim	delete_set.cpp	/^int delete_get_victim(delete_set *set){$/;"	f
tags:delete_init	delete_set.cpp	/^void delete_init(){\/\/for test$/;"	f
tags:delete_make_req	delete_set.cpp	/^lsmtree_req_t * delete_make_req(bool iswrite){$/;"	f
tags:delete_ppa	delete_set.cpp	/^void delete_ppa(delete_set *set,KEYT input){$/;"	f
tags:delete_set	ppa.h	/^typedef segment delete_set;$/;"	t
tags:delete_trim_process_data	delete_set.cpp	/^int delete_trim_process_data(delete_set *set){$/;"	f
tags:delete_trim_process_header	delete_set.cpp	/^int delete_trim_process_header(delete_set *set){$/;"	f
tags:header_segment	delete_set.cpp	/^delete_set *header_segment;$/;"	v
tags:level_delete	bptree.cpp	/^Node * level_delete(level *lev, KEYT key){$/;"	f
tags:level_delete_restructuring	bptree.cpp	/^Node *level_delete_restructuring(level *lev, Node *target){$/;"	f
tags:oob	delete_set.cpp	/^uint64_t *oob;$/;"	v
tags:skiplist_delete	skiplist.cpp	/^int skiplist_delete(skiplist* list, KEYT key){$/;"	f
test.c:#include"delete_set.h"
test.c:extern delete_set* dset;
test.c:	dset=(delete_set*)malloc(sizeof(delete_set));
test.c:	delete_init(dset);
test.c:		delete_ppa(dset,i);
test.c:	while(delete_trim_process(dset)){
test.c:		printf("deleted!\n");
threading.cpp:	delete input->req_q;
threading.cpp:	delete input->gc_q;
delete_set.cpp:#include"delete_set.h"
delete_set.cpp:delete_set *data_segment;
delete_set.cpp:delete_set *header_segment;
delete_set.cpp:lsmtree_req_t * delete_make_req(bool iswrite){
delete_set.cpp:void delete_init(){//for test
delete_set.cpp:	data_segment=(delete_set*)malloc(sizeof(delete_set));
delete_set.cpp:	header_segment=(delete_set *)malloc(sizeof(delete_set));
delete_set.cpp:void delete_ppa(delete_set *set,KEYT input){
delete_set.cpp:int delete_get_victim(delete_set *set){
delete_set.cpp:int delete_trim_process_header(delete_set *set){
delete_set.cpp:	int block_num=delete_get_victim(set); //segment's order
delete_set.cpp:				lsmtree_req_t *req=delete_make_req(0);
delete_set.cpp:				req=delete_make_req(1);
delete_set.cpp:				delete_ppa(set,temp_pba);
delete_set.cpp:int delete_trim_process_data(delete_set *set){
delete_set.cpp:	int block_num=delete_get_victim(set);
delete_set.cpp:				lsmtree_req_t *req=delete_make_req(0);
delete_set.cpp:						req=delete_make_req(0);
delete_set.cpp:								req=delete_make_req(1);
delete_set.cpp:								delete_ppa(header_segment,temp_pba);
delete_set.cpp:				req=delete_make_req(1);
